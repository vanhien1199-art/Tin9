<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Tr·ª£ l√Ω Scratch - H·ªèi ƒë√°p</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Google Fonts for modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        :root{
            --primary: #1479ff;
            --accent: #ffa940;
            --bg-start: #f4f7fc;
            --bg-end: #e6f0ff;
            --card: #ffffff;
            --text: #14182a;
            --muted: #6d758c;
            --radius: 16px;
            --shadow-1: 0 6px 24px rgba(20,121,255,0.08);
            --glass: rgba(255,255,255,0.6);
        }

        html,body{
            height:100%;
            margin:0;
            font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            -webkit-font-smoothing:antialiased;
            -moz-osx-font-smoothing:grayscale;
            background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
            color:var(--text);
            scroll-behavior:smooth;
        }

        /* Layout */
        .container{
            max-width:980px;
            margin:20px auto 80px;
            padding:0 18px;
        }

        header{
            background: linear-gradient(90deg, var(--primary), #64b5f6 90%);
            color:#fff;
            padding:18px 14px;
            text-align:center;
            border-bottom-left-radius:20px;
            border-bottom-right-radius:20px;
            box-shadow: var(--shadow-1);
            position:relative;
        }
        .home-btn{
            position:absolute;
            left:12px;
            top:12px;
            font-size:1.5rem;
            color:#fff;
            text-decoration:none;
            opacity:0.95;
        }
        header h1{
            margin:0;
            font-size:1.2rem;
            letter-spacing:-0.5px;
            font-weight:700;
        }

        /* Chat card */
        .card{
            background: linear-gradient(180deg, rgba(255,255,255,0.92), rgba(250,252,255,0.98));
            border-radius:var(--radius);
            box-shadow: var(--shadow-1);
            padding:14px;
            margin-top:16px;
            transition:transform .12s ease, box-shadow .12s ease;
            display:flex;
            flex-direction:column;
            gap:10px;
        }
        .card:active{ transform:translateY(0); }

        /* Header row */
        .chat-header-row{
            display:flex;
            align-items:center;
            gap:12px;
            justify-content:space-between;
        }
        #ai-chatbot-card h2{ font-size:1.05rem; margin:0; display:flex; align-items:center; gap:10px; }
        #ai-chatbot-card p{ margin:6px 0 0; color:var(--muted); font-size:0.95rem; }

        .chat-controls{ display:flex; gap:8px; align-items:center; }
        .icon-btn{
            background:transparent;
            border: none;
            cursor:pointer;
            padding:8px;
            border-radius:10px;
            color:var(--primary);
            font-size:1rem;
        }
        .icon-btn[aria-pressed="true"]{ background:rgba(20,121,255,0.06); }

        /* Chat window */
        .chat-window{
            flex:1 1 auto;
            min-height:300px;
            border-radius:12px;
            padding:12px;
            display:flex;
            flex-direction:column;
            gap:10px;
            overflow-y:auto;
            -webkit-overflow-scrolling: touch;
            border:1px solid rgba(16,24,64,0.06);
            background: linear-gradient(180deg, rgba(249,252,255,0.9), rgba(245,248,255,0.92));
        }

        /* Message bubbles */
        .chat-message{
            max-width:82%;
            padding:10px 14px;
            border-radius:18px;
            font-size:0.98rem;
            line-height:1.45;
            word-break:break-word;
            white-space:pre-wrap;
            box-shadow: 0 2px 10px rgba(16,24,64,0.03);
        }
        .ai-message{
            align-self:flex-start;
            background: linear-gradient(180deg, #f6f8ff, #eef3ff);
            color:var(--text);
            border-bottom-left-radius:8px;
            border-top-right-radius:8px;
        }
        .user-message{
            align-self:flex-end;
            background: linear-gradient(90deg, var(--primary) 0%, #1a1a1a 100%);
            color:#fff;
            border-bottom-right-radius:8px;
            border-top-left-radius:8px;
        }
        /* small timestamp / meta (optional) */
        .msg-meta{ display:block; font-size:0.75rem; color:var(--muted); margin-top:6px; }

        /* Input area */
        .chat-input-area{
            display:flex;
            gap:10px;
            align-items:center;
            margin-top:6px;
        }
        .chat-input-area input[type="text"]{
            flex:1;
            padding:12px 14px;
            border-radius:24px;
            border:1px solid #e4e9f5;
            font-size:1rem;
            background:#fff;
            outline:none;
            transition:box-shadow .12s ease, border-color .12s ease;
        }
        .chat-input-area input[type="text"]:focus{ box-shadow:0 6px 22px rgba(20,121,255,0.06); border-color:var(--primary); }
        .chat-input-area button.send-btn{
            background:var(--accent);
            color:#fff;
            border:none;
            padding:10px 14px;
            border-radius:20px;
            cursor:pointer;
            font-weight:600;
            box-shadow:0 6px 18px rgba(255,169,64,0.12);
        }

        /* Attachment preview area */
        .attachment-preview{
            display:flex;
            gap:8px;
            flex-wrap:wrap;
            align-items:center;
            margin-bottom:8px;
        }
        .attachment-item{
            background:rgba(16,24,64,0.04);
            border-radius:10px;
            padding:6px;
            display:flex;
            gap:8px;
            align-items:center;
            max-width:70%;
        }
        .attachment-thumb{
            width:56px;
            height:40px;
            object-fit:cover;
            border-radius:6px;
            background:#fff;
            display:inline-block;
            border:1px solid rgba(16,24,64,0.06);
        }
        .attachment-meta{
            display:flex;
            flex-direction:column;
            gap:4px;
            font-size:0.85rem;
            color:var(--muted);
            max-width:calc(100% - 64px);
            overflow:hidden;
            text-overflow:ellipsis;
            white-space:nowrap;
        }
        .attachment-remove{
            background:transparent;
            border:none;
            color:#ff6b6b;
            cursor:pointer;
            font-size:1.05rem;
            padding:4px;
            margin-left:6px;
        }

        .upload-progress {
            font-size:0.9rem;
            color:var(--muted);
            margin-top:6px;
        }

        /* Fullscreen */
        #ai-chatbot-card.chat-fullscreen{
            position:fixed;
            inset:0;
            width:100vw;
            height:100vh;
            margin:0;
            border-radius:0;
            z-index:9999;
            padding:18px;
            background: linear-gradient(180deg, #fff, #f6fbff);
        }
        #ai-chatbot-card.chat-fullscreen .chat-window{
            height: calc(100vh - 200px);
            min-height: 380px;
        }

        /* Footer - smaller and simplified */
        .site-footer{
            background: linear-gradient(90deg, #232d46, #334877 90%);
            color:#e7eaf1;
            padding:12px 0;
            font-size:0.92rem;
            box-shadow: 0 -4px 22px rgba(52,103,217,0.06);
        }
        .footer-inner{
            max-width:900px;
            margin:0 auto;
            padding:8px 18px;
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:12px;
        }
        .footer-contact a{ color:#ffd9a6; text-decoration:none; font-weight:600; }
        .footer-note{ color:#c7cbe0; font-size:0.86rem; }

        /* Responsive */
        @media (max-width:700px){
            .container{ padding:0 12px 90px; margin-top:10px; }
            header{ padding:12px; }
            header h1{ font-size:1.05rem; }
            .card{ padding:12px; border-radius:14px; }
            .chat-window{ min-height: 260px; padding:10px; }
            #ai-chatbot-card.chat-fullscreen .chat-window{ height: calc(100vh - 170px); }
            .chat-input-area input{ padding:10px 12px; font-size:0.98rem; }
            .attachment-thumb{ width:48px; height:36px; }
        }
        @media (max-width:420px){
            .chat-window{ min-height:220px; }
            .chat-input-area button{ padding:9px 12px; font-size:0.95rem; }
            .footer-inner{ flex-direction:column; align-items:center; gap:6px; text-align:center; padding:10px 12px; }
        }
    </style>
</head>
<body id="page-top">
    <header>
        <a href="/" class="home-btn" title="V·ªÅ trang ch·ªß">üè†</a>
        <h1>Tr·ª£ l√Ω H·ªçc Scratch</h1>
    </header>

    <div class="container">
        <section id="ai-chatbot-card" class="card" aria-label="Tr·ª£ l√Ω Scratch chat">
            <div class="chat-header-row">
                <h2>
                    <span style="display:inline-flex;align-items:center;">
                        <svg width="34" height="34" viewBox="0 0 48 48" fill="none" style="margin-right:8px;vertical-align:middle;">
                          <rect x="8" y="14" width="32" height="24" rx="12" fill="#1479ff"/>
                          <rect x="16" y="22" width="16" height="8" rx="4" fill="#fff"/>
                          <circle cx="18" cy="26" r="2" fill="#1479ff"/>
                          <circle cx="30" cy="26" r="2" fill="#1479ff"/>
                          <rect x="21" y="8" width="6" height="6" rx="3" fill="#ffa940"/>
                          <rect x="29" y="8" width="6" height="6" rx="3" fill="#ffa940"/>
                        </svg>
                        Tr·ª£ l√Ω Scratch
                    </span>
                </h2>

                <div class="chat-controls" role="toolbar" aria-label="Chat controls">
                    <button id="toggle-fullscreen-btn" class="icon-btn" title="To√†n m√†n h√¨nh" aria-pressed="false">‚§¢</button>
                    <button id="close-fullscreen-btn" class="icon-btn" title="ƒê√≥ng to√†n m√†n h√¨nh" aria-pressed="false" style="display:none">‚úï</button>
                </div>
            </div>

            <p>Xin ch√†o! M√¨nh l√† Mentor Scratch ‚Äî h·ªèi g√¨ c·ª© h·ªèi nh√©.</p>

            <div id="chat-window" class="chat-window" aria-live="polite">
                <div class="chat-message ai-message">
            Hi! T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay?
                </div>
            </div>

            <!-- Attachment preview area (new) -->
            <div id="attachment-preview" class="attachment-preview" aria-hidden="true" style="display:none"></div>

            <div class="chat-input-area" role="form" aria-label="G·ª≠i tin nh·∫Øn">
                <!-- Attach button -->
                <label for="file-input" class="icon-btn" title="ƒê√≠nh k√®m t·ªáp">üìé</label>
                <!-- accept includes image/* for camera access on mobile; capture hint provided so mobile browsers offer camera -->
                <input type="file" id="file-input" accept="image/*,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation,application/zip" multiple style="display:none" aria-label="Ch·ªçn t·ªáp ƒë√≠nh k√®m" capture="environment">

                <input type="text" id="user-input" placeholder="ƒê·∫∑t c√¢u h·ªèi b·∫•t k·ª≥..." autocomplete="off" aria-label="N·ªôi dung c√¢u h·ªèi">
                <button id="send-button" class="send-btn">G·ª≠i</button>
            </div>
        </section>
    </div>

    <footer class="site-footer" aria-hidden="false">
                       userMsg.appendChild(wrapper);
            }

            chatWindow.appendChild(userMsg);
            chatWindow.scrollTo({ top: chatWindow.scrollHeight, behavior: 'smooth' });
        }

        // Upload helper using XMLHttpRequest so we can track progress.
        // If window.UPLOAD_ENDPOINT is not set, we'll fallback to client blob URLs.
        function uploadAttachmentsWithProgress(formData, onProgress) {
            return new Promise((resolve, reject) => {
                const endpoint = window.UPLOAD_ENDPOINT || null;
                if (!endpoint) {
                    reject(new Error('NO_ENDPOINT'));
                    return;
                }
                const xhr = new XMLHttpRequest();
                xhr.open('POST', endpoint, true);
                // optional: set auth header if provided
                if (window.UPLOAD_AUTH_TOKEN) {
                    xhr.setRequestHeader('Authorization', 'Bearer ' + window.UPLOAD_AUTH_TOKEN);
                }

                xhr.upload.onprogress = function(e) {
                    if (e.lengthComputable && typeof onProgress === 'function') {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        onProgress(percent);
                    }
                };

                xhr.onload = function() {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            const json = JSON.parse(xhr.responseText);
                            resolve(json);
                        } catch (err) {
                            // If server responded with plain URL or text, return that
                            resolve({ urls: [xhr.responseText] });
                        }
                    } else {
                        reject(new Error('Upload failed: ' + xhr.status));
                    }
                };

                xhr.onerror = function() {
                    reject(new Error('Network error during upload'));
                };

                xhr.send(formData);
            });
        }

        // When send button pressed, handle attachments (upload if endpoint configured) then create message
        sendBtn.addEventListener('click', async function(e){
            const textValue = userInput.value && userInput.value.trim() ? userInput.value.trim() : '';

            if (attachments.length === 0) {
                // No attachments: let chatbot.js handle text-only sends.
                // We do not prevent default here to not interfere.
                return;
            }

            // If there's an upload endpoint configured, upload files first.
            if (window.UPLOAD_ENDPOINT) {
                // Prepare FormData
                const fd = new FormData();
                if (textValue) fd.append('message', textValue);
                attachments.forEach((att, idx) => {
                    fd.append('files[]', att.file, att.file.name);
                });

                // Show uploading progress in preview area
                renderAttachments('ƒêang t·∫£i l√™n... 0%');

                try {
                    const response = await uploadAttachmentsWithProgress(fd, (percent) => {
                        renderAttachments('ƒêang t·∫£i l√™n... ' + percent + '%');
                    });

                    // Normalize response to array of URLs if possible
                    let urls = [];
                    if (Array.isArray(response)) {
                        urls = response;
                    } else if (response && Array.isArray(response.urls)) {
                        urls = response.urls;
                    } else if (typeof response === 'string') {
                        urls = [response];
                    } else if (response && response.url) {
                        urls = [response.url];
                    }

                    // Partition urls into images and non-images by extension / heuristics
                    const imageUrls = [];
                    const fileLinks = [];
                    urls.forEach(u => {
                        const lower = (u || '').toLowerCase();
                        if (lower.match(/\.(jpg|jpeg|png|gif|webp|avif|bmp)(\?|$)/)) {
                            imageUrls.push(u);
                        } else {
                            fileLinks.push({ url: u, name: u.split('/').pop() });
                        }
                    });

                    // Append a user message with uploaded images/links
                    const textForMessage = textValue || '(ƒê√£ g·ª≠i t·ªáp)';
                    appendUserMessage(textForMessage, imageUrls, fileLinks);

                    // Clear attachments and input
                    attachments.forEach(a => { if (a.url && a.file.type.startsWith('image/')) URL.revokeObjectURL(a.url); });
                    attachments = [];
                    renderAttachments();

                    // Provide uploaded URLs globally for chatbot.js or other listeners
                    window.__lastUploadResponse = { uploaded: urls };

                    // Dispatch event with uploaded URLs so other scripts can integrate (chatbot.js can listen)
                    const ev = new CustomEvent('attachmentsUploaded', { detail: { urls } });
                    document.dispatchEvent(ev);

                    // Also clear the input field (chatbot.js may still send text if it handles send click; you may coordinate)
                    userInput.value = '';

                } catch (err) {
                    console.error(err);
                    alert('Kh√¥ng th·ªÉ t·∫£i t·ªáp l√™n: ' + (err.message || err));
                    // Fall back to local blob URLs display
                    const imageUrls = attachments.filter(a => a.file.type.startsWith('image/')).map(a => a.url);
                    const fileLinks = attachments.filter(a => !a.file.type.startsWith('image/')).map(a => {
                        const blobUrl = URL.createObjectURL(a.file);
                        setTimeout(() => URL.revokeObjectURL(blobUrl), 60*1000);
                        return { url: blobUrl, name: a.file.name };
                    });
                    appendUserMessage(textValue || '(ƒê√£ g·ª≠i t·ªáp)', imageUrls, fileLinks);

                    attachments.forEach(a => { if (a.url && a.file.type.startsWith('image/')) URL.revokeObjectURL(a.url); });
                    attachments = [];
                    renderAttachments();
                    userInput.value = '';
                }

                return;
            }

            // If no endpoint configured, fallback: show inline blob URLs (client-only)
            const imageUrls = attachments.filter(a => a.file.type.startsWith('image/')).map(a => a.url);
            const fileLinks = attachments.filter(a => !a.file.type.startsWith('image/')).map(a => {
                const blobUrl = URL.createObjectURL(a.file);
                setTimeout(() => URL.revokeObjectURL(blobUrl), 60*1000);
                return { url: blobUrl, name: a.file.name };
            });

            appendUserMessage(textValue || '(ƒê√£ g·ª≠i t·ªáp)', imageUrls, fileLinks);

            // Clear attachments and input
            attachments.forEach(a => { if (a.url && a.file.type.startsWith('image/')) URL.revokeObjectURL(a.url); });
            attachments = [];
            renderAttachments();
            userInput.value = '';

            // Provide a simple event so chatbot.js can be aware (it should still handle text send separately)
            const dispatched = new CustomEvent('attachmentsSent', { detail: { uploaded: false, count: 0 } });
            document.dispatchEvent(dispatched);
        });
    });
    </script>
    <!-- m√£ m·ªõi(k√≠ch ho·∫°t) chatbot -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // C√°c bi·∫øn n√†y ƒë√£ ƒë∆∞·ª£c khai b√°o ·ªü script block ph√≠a tr√™n,
        // nh∆∞ng ch√∫ng ta tham chi·∫øu l·∫°i ·ªü ƒë√¢y cho r√µ r√†ng
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-button');
        const chatWindow = document.getElementById('chat-window');
        
        // (Bi·∫øn `attachments` v√† h√†m `renderAttachments` ƒë√£ t·ªìn t·∫°i
        // t·ª´ script block tr∆∞·ªõc ƒë√≥ trong file c·ªßa b·∫°n)

        // === H√ÄM TR·ª¢ GI√öP ===

        /**
         * Chuy·ªÉn ƒë·ªïi File object sang Base64 string
         * @param {File} file - File ng∆∞·ªùi d√πng ch·ªçn
         * @returns {Promise<String>} - D·ªØ li·ªáu Base64 (ch·ªâ l·∫•y ph·∫ßn data)
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    // C·∫Øt b·ªè ph·∫ßn "data:image/jpeg;base64,"
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = (error) => reject(error);
            });
        }

        /**
         * Th√™m tin nh·∫Øn v√†o c·ª≠a s·ªï chat
         * @param {String} message - N·ªôi dung (HTML)
         * @param {String} sender - "user" ho·∫∑c "ai"
         * @returns {HTMLElement} - Element c·ªßa tin nh·∫Øn v·ª´a t·∫°o
         */
        function appendMessage(message, sender) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${sender}-message`;
            
            if (sender === 'ai') {
                // D√πng th∆∞ vi·ªán `marked` ƒë√£ import ƒë·ªÉ render Markdown
                msgDiv.innerHTML = marked.parse(message);
            } else {
                // Tin nh·∫Øn c·ªßa user, ch·ªâ hi·ªÉn th·ªã text
                msgDiv.innerText = message;
            }
            
            chatWindow.appendChild(msgDiv);
            chatWindow.scrollTo({ top: chatWindow.scrollHeight, behavior: 'smooth' });
            return msgDiv;
        }

        /**
         * X·ª≠ l√Ω ch√≠nh khi nh·∫•n n√∫t G·ª≠i
         */
        async function handleSend() {
            const textValue = userInput.value.trim();
            
            // L·∫•y danh s√°ch t·ªáp ƒë√≠nh k√®m (bi·∫øn `attachments` n√†y l√† global 
            // ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong script block tr∆∞·ªõc c·ªßa b·∫°n)
            const currentAttachments = [...window.attachments];

            if (!textValue && currentAttachments.length === 0) {
                return; // Kh√¥ng g·ª≠i n·∫øu kh√¥ng c√≥ g√¨
            }
            
            // 1. V√¥ hi·ªáu h√≥a input v√† x√≥a t·ªáp ƒë√≠nh k√®m
            userInput.value = '';
            userInput.disabled = true;
            sendBtn.disabled = true;
            
            // X√≥a c√°c t·ªáp kh·ªèi UI
            if (currentAttachments.length > 0) {
                 // X√≥a t·∫•t c·∫£ (v√¨ `attachments` l√† m·∫£ng global)
                window.attachments.length = 0; 
                renderAttachments(); // C·∫≠p nh·∫≠t l·∫°i UI
            }

            // 2. Hi·ªÉn th·ªã tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
            // (Ch√∫ng ta s·∫Ω hi·ªÉn th·ªã c·∫£ text v√† thumbnail trong tin nh·∫Øn)
            let userMessageContent = textValue;
            if (currentAttachments.length > 0) {
                 userMessageContent += `\n(ƒê√£ g·ª≠i ${currentAttachments.length} t·ªáp ƒë√≠nh k√®m)`;
            }
            appendMessage(userMessageContent, 'user');
            
            // 3. Hi·ªÉn th·ªã th√¥ng b√°o "AI ƒëang tr·∫£ l·ªùi..."
            const loadingMsg = appendMessage('Mentor Scratch ƒëang suy nghƒ©... ü§ñ', 'ai');

            // 4. Chu·∫©n b·ªã payload ƒë·ªÉ g·ª≠i l√™n backend
            const payload = {
                question: textValue,
                lesson_id: 'default', // B·∫°n c√≥ th·ªÉ thay ƒë·ªïi n·∫øu c·∫ßn
                attachments: [] // M·∫£ng ch·ª©a c√°c t·ªáp ƒë√£ convert
            };

            try {
                // 5. Chuy·ªÉn ƒë·ªïi c√°c t·ªáp ƒë√≠nh k√®m sang Base64
                for (const att of currentAttachments) {
                    // CH·ªà G·ª¨I ·∫¢NH: M√¥ h√¨nh AI n√†y ch·ªâ ƒë·ªçc ƒë∆∞·ª£c ·∫£nh
                    if (att.file.type.startsWith('image/')) {
                        const base64Data = await fileToBase64(att.file);
                        payload.attachments.push({
                            mimeType: att.file.type,
                            base64Data: base64Data
                        });
                    }
                    // C√°c file kh√°c (PDF, .sb3...) s·∫Ω b·ªã b·ªè qua khi g·ª≠i cho AI
                    // v√¨ m√¥ h√¨nh hi·ªán t·∫°i kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ch√∫ng
                }

                // 6. G·ªçi Cloudflare Function
                // !! QUAN TR·ªåNG: Thay ƒë·ªïi URL n√†y th√†nh URL function c·ªßa b·∫°n
                const response = await fetch('/functions/askAI', { 
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.error || `L·ªói ${response.status}`);
                }

                const data = await response.json();
                
                // 7. C·∫≠p nh·∫≠t tin nh·∫Øn "loading" b·∫±ng c√¢u tr·∫£ l·ªùi th·∫≠t
                // D√πng `marked.parse` ƒë·ªÉ render c√°c ƒë·ªãnh d·∫°ng Markdown (nh∆∞ kh·ªëi l·ªánh)
                loadingMsg.innerHTML = marked.parse(data.answer);

            } catch (error) {
                console.error('L·ªói khi g·ªçi AI:', error);
                loadingMsg.innerHTML = `<strong>R·∫•t ti·∫øc, ƒë√£ c√≥ l·ªói x·∫£y ra:</strong><br>${error.message}`;
                loadingMsg.style.color = 'red';
            } finally {
                // 8. K√≠ch ho·∫°t l·∫°i input
                userInput.disabled = false;
                sendBtn.disabled = false;
                userInput.focus();
            }
        }

        // G√°n s·ª± ki·ªán cho n√∫t G·ª≠i
        sendBtn.addEventListener('click', handleSend);
        
        // G√°n s·ª± ki·ªán cho Enter
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSend();
            }
        });

    });
    </script>
</body>
</html>

